{"pageProps":{"post":{"attributes":{"title":"Promise Methods and Error Handling"},"html":"<p><strong>Lesson 2: Promise Methods and Error Handling</strong></p>\n<p>In the previous lesson, we introduced Promises and showed you the basics of using them for data fetching. In this lesson, we will explore some common Promise methods and more advanced error handling techniques.</p>\n<p><strong>1. Promise Methods:</strong></p>\n<p>Promises come with a set of methods that make working with asynchronous code more convenient.</p>\n<ul>\n<li><p><strong><code>Promise.all()</code></strong>: This method takes an array of Promises and returns a single Promise that fulfills when all the Promises in the array fulfill or rejects when any one of them rejects. It&#39;s useful for parallel operations.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> promise1 = <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;https://api.example.com/data1&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> promise2 = <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;https://api.example.com/data2&#x27;</span>);\n\n<span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([promise1, promise2])\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">responses</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// Handle the responses from both requests</span>\n    <span class=\"hljs-keyword\">const</span> data1 = responses[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">json</span>();\n    <span class=\"hljs-keyword\">const</span> data2 = responses[<span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">json</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([data1, data2]);\n  })\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// Work with the combined data</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data[<span class=\"hljs-number\">0</span>], data[<span class=\"hljs-number\">1</span>]);\n  })\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// Handle errors from any of the Promises</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;Promise.all error:&#x27;</span>, error);\n  });\n</code></pre>\n</li>\n<li><p><strong><code>Promise.race()</code></strong>: This method takes an array of Promises and returns a new Promise that fulfills or rejects as soon as one of the Promises in the array does. It&#39;s useful for scenarios where you want the result of the first responding Promise.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> promise1 = <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;https://api.example.com/data1&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> promise2 = <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;https://api.example.com/data2&#x27;</span>);\n\n<span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([promise1, promise2])\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// Handle the response from the first successful request</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(response);\n  })\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// Handle errors from the first rejecting Promise</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;Promise.race error:&#x27;</span>, error);\n  });\n</code></pre>\n</li>\n</ul>\n<p><strong>2. Error Handling:</strong></p>\n<p>Error handling is a critical aspect of asynchronous code. In addition to using <code>.catch()</code> as shown earlier, you can also handle errors inside individual <code>.then()</code> blocks by returning a rejected Promise using <code>Promise.reject()</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;https://api.example.com/data&#x27;</span>)\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (!response.<span class=\"hljs-property\">ok</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-string\">&#x27;Network response was not ok&#x27;</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>();\n  })\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// Work with the fetched data</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n  })\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// Handle errors here</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;Fetch error:&#x27;</span>, error);\n  });\n</code></pre>\n<p><strong>3. Async/Await:</strong></p>\n<p>While Promises provide a powerful way to work with asynchronous code, modern JavaScript also introduced the <code>async/await</code> syntax, which makes asynchronous code look more like synchronous code. Here&#39;s how you can rewrite the previous example using <code>async/await</code>:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;https://api.example.com/data&#x27;</span>);\n    \n    <span class=\"hljs-keyword\">if</span> (!response.<span class=\"hljs-property\">ok</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Network response was not ok&#x27;</span>);\n    }\n\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n    <span class=\"hljs-comment\">// Work with the fetched data</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-comment\">// Handle errors here</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;Fetch error:&#x27;</span>, error);\n  }\n}\n\n<span class=\"hljs-title function_\">fetchData</span>();\n</code></pre>\n<p><code>async/await</code> simplifies the syntax and makes it easier to read and write asynchronous code.</p>\n<p>That concludes the second lesson on JavaScript data fetching and Promises, covering Promise methods and error handling techniques. In the next lesson, we&#39;ll explore more advanced topics such as handling multiple asynchronous operations and managing complex data flows.</p>\n","markdown":"\n**Lesson 2: Promise Methods and Error Handling**\n\nIn the previous lesson, we introduced Promises and showed you the basics of using them for data fetching. In this lesson, we will explore some common Promise methods and more advanced error handling techniques.\n\n**1. Promise Methods:**\n\nPromises come with a set of methods that make working with asynchronous code more convenient.\n\n- **`Promise.all()`**: This method takes an array of Promises and returns a single Promise that fulfills when all the Promises in the array fulfill or rejects when any one of them rejects. It's useful for parallel operations.\n\n  ```javascript\n  const promise1 = fetch('https://api.example.com/data1');\n  const promise2 = fetch('https://api.example.com/data2');\n\n  Promise.all([promise1, promise2])\n    .then(responses => {\n      // Handle the responses from both requests\n      const data1 = responses[0].json();\n      const data2 = responses[1].json();\n      return Promise.all([data1, data2]);\n    })\n    .then(data => {\n      // Work with the combined data\n      console.log(data[0], data[1]);\n    })\n    .catch(error => {\n      // Handle errors from any of the Promises\n      console.error('Promise.all error:', error);\n    });\n  ```\n\n- **`Promise.race()`**: This method takes an array of Promises and returns a new Promise that fulfills or rejects as soon as one of the Promises in the array does. It's useful for scenarios where you want the result of the first responding Promise.\n\n  ```javascript\n  const promise1 = fetch('https://api.example.com/data1');\n  const promise2 = fetch('https://api.example.com/data2');\n\n  Promise.race([promise1, promise2])\n    .then(response => {\n      // Handle the response from the first successful request\n      console.log(response);\n    })\n    .catch(error => {\n      // Handle errors from the first rejecting Promise\n      console.error('Promise.race error:', error);\n    });\n  ```\n\n**2. Error Handling:**\n\nError handling is a critical aspect of asynchronous code. In addition to using `.catch()` as shown earlier, you can also handle errors inside individual `.then()` blocks by returning a rejected Promise using `Promise.reject()`.\n\n```javascript\nfetch('https://api.example.com/data')\n  .then(response => {\n    if (!response.ok) {\n      return Promise.reject('Network response was not ok');\n    }\n    return response.json();\n  })\n  .then(data => {\n    // Work with the fetched data\n    console.log(data);\n  })\n  .catch(error => {\n    // Handle errors here\n    console.error('Fetch error:', error);\n  });\n```\n\n**3. Async/Await:**\n\nWhile Promises provide a powerful way to work with asynchronous code, modern JavaScript also introduced the `async/await` syntax, which makes asynchronous code look more like synchronous code. Here's how you can rewrite the previous example using `async/await`:\n\n```javascript\nasync function fetchData() {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    \n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n\n    const data = await response.json();\n    // Work with the fetched data\n    console.log(data);\n  } catch (error) {\n    // Handle errors here\n    console.error('Fetch error:', error);\n  }\n}\n\nfetchData();\n```\n\n`async/await` simplifies the syntax and makes it easier to read and write asynchronous code.\n\nThat concludes the second lesson on JavaScript data fetching and Promises, covering Promise methods and error handling techniques. In the next lesson, we'll explore more advanced topics such as handling multiple asynchronous operations and managing complex data flows.","slug":"Methods","title":"Promise Methods and Error Handling","section":"Promises and Data Fetching","icon":"info-circle","filePath":"/home/runner/work/amanj-course/amanj-course/lessons/07-Promises-and-Data-Fetching/02-Methods.md","nextSlug":"/amanj-course/lessons/Promises-and-Data-Fetching/Flow","prevSlug":"/amanj-course/lessons/Promises-and-Data-Fetching/Introduction"}},"__N_SSG":true}