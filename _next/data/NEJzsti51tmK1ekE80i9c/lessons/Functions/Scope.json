{"pageProps":{"post":{"attributes":{"title":"Function Scope and Hoisting in JavaScript"},"html":"<p><strong>Lesson 2: Function Scope and Hoisting in JavaScript</strong></p>\n<p>In this lesson, we&#39;ll dive deeper into the concepts of function scope and hoisting in JavaScript. Understanding these concepts is crucial for writing reliable and predictable code.</p>\n<p><strong>1. Function Scope:</strong>\nVariables declared inside a function are said to have function scope. This means they are only accessible within that function. Variables declared outside any function have global scope, making them accessible throughout the entire script.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> localVar = <span class=\"hljs-string\">&quot;I&#x27;m local!&quot;</span>;\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(localVar); <span class=\"hljs-comment\">// Output: I&#x27;m local!</span>\n}\n\n<span class=\"hljs-title function_\">myFunction</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(localVar); <span class=\"hljs-comment\">// Error: localVar is not defined</span>\n</code></pre>\n<p><strong>2. Hoisting:</strong>\nJavaScript &quot;hoists&quot; variable and function declarations to the top of their containing scope during compilation, regardless of where they&#39;re defined. However, only the declarations are hoisted, not the assignments. This can lead to unexpected behavior if not understood properly.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myVar); <span class=\"hljs-comment\">// Output: undefined</span>\n<span class=\"hljs-keyword\">var</span> myVar = <span class=\"hljs-number\">42</span>;\n\n<span class=\"hljs-title function_\">hoistedFunction</span>(); <span class=\"hljs-comment\">// Output: &quot;Hello, hoisting!&quot;</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hoistedFunction</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Hello, hoisting!&quot;</span>);\n}\n</code></pre>\n<p><strong>3. Function Declarations vs. Function Expressions:</strong>\nFunction declarations are entirely hoisted, so you can call them before their actual declaration in the code. Function expressions, on the other hand, are only partially hoisted. The variable declaration is hoisted, but the function assignment isn&#39;t.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title function_\">declarationFunction</span>(); <span class=\"hljs-comment\">// Output: &quot;This is a function declaration.&quot;</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">declarationFunction</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;This is a function declaration.&quot;</span>);\n}\n\n<span class=\"hljs-title function_\">expressionFunction</span>(); <span class=\"hljs-comment\">// Error: expressionFunction is not a function</span>\n<span class=\"hljs-keyword\">var</span> expressionFunction = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;This is a function expression.&quot;</span>);\n};\n</code></pre>\n<p><strong>4. Block Scope (ES6):</strong>\nBefore ES6, JavaScript only had function and global scope. With ES6, the <code>let</code> and <code>const</code> keywords introduced block scope, making variables confined to the block in which they&#39;re defined.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">var</span> blockVar = <span class=\"hljs-string\">&quot;I&#x27;m a block-scoped var.&quot;</span>;\n    <span class=\"hljs-keyword\">let</span> blockLet = <span class=\"hljs-string\">&quot;I&#x27;m a block-scoped let.&quot;</span>;\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(blockVar); <span class=\"hljs-comment\">// Output: I&#x27;m a block-scoped var.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(blockLet); <span class=\"hljs-comment\">// Error: blockLet is not defined</span>\n</code></pre>\n<p><strong>5. Lexical Scope:</strong>\nLexical scope means that functions are executed using the variable scope that was in effect when they were defined, not the scope they are executed in.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">outer</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> localVar = <span class=\"hljs-string\">&quot;I&#x27;m from outer.&quot;</span>;\n    \n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">inner</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(localVar); <span class=\"hljs-comment\">// Output: I&#x27;m from outer.</span>\n    };\n    \n    <span class=\"hljs-keyword\">return</span> inner;\n};\n\n<span class=\"hljs-keyword\">const</span> innerFunction = <span class=\"hljs-title function_\">outer</span>();\n<span class=\"hljs-title function_\">innerFunction</span>();\n</code></pre>\n<p>These are the key concepts related to function scope and hoisting in JavaScript. Properly understanding and managing scope and hoisting is crucial for writing code that behaves predictably and avoids bugs.</p>\n","markdown":"\n**Lesson 2: Function Scope and Hoisting in JavaScript**\n\nIn this lesson, we'll dive deeper into the concepts of function scope and hoisting in JavaScript. Understanding these concepts is crucial for writing reliable and predictable code.\n\n**1. Function Scope:**\nVariables declared inside a function are said to have function scope. This means they are only accessible within that function. Variables declared outside any function have global scope, making them accessible throughout the entire script.\n\n```javascript\nfunction myFunction() {\n    const localVar = \"I'm local!\";\n    console.log(localVar); // Output: I'm local!\n}\n\nmyFunction();\nconsole.log(localVar); // Error: localVar is not defined\n```\n\n**2. Hoisting:**\nJavaScript \"hoists\" variable and function declarations to the top of their containing scope during compilation, regardless of where they're defined. However, only the declarations are hoisted, not the assignments. This can lead to unexpected behavior if not understood properly.\n\n```javascript\nconsole.log(myVar); // Output: undefined\nvar myVar = 42;\n\nhoistedFunction(); // Output: \"Hello, hoisting!\"\nfunction hoistedFunction() {\n    console.log(\"Hello, hoisting!\");\n}\n```\n\n**3. Function Declarations vs. Function Expressions:**\nFunction declarations are entirely hoisted, so you can call them before their actual declaration in the code. Function expressions, on the other hand, are only partially hoisted. The variable declaration is hoisted, but the function assignment isn't.\n\n```javascript\ndeclarationFunction(); // Output: \"This is a function declaration.\"\nfunction declarationFunction() {\n    console.log(\"This is a function declaration.\");\n}\n\nexpressionFunction(); // Error: expressionFunction is not a function\nvar expressionFunction = function() {\n    console.log(\"This is a function expression.\");\n};\n```\n\n**4. Block Scope (ES6):**\nBefore ES6, JavaScript only had function and global scope. With ES6, the `let` and `const` keywords introduced block scope, making variables confined to the block in which they're defined.\n\n```javascript\nif (true) {\n    var blockVar = \"I'm a block-scoped var.\";\n    let blockLet = \"I'm a block-scoped let.\";\n}\n\nconsole.log(blockVar); // Output: I'm a block-scoped var.\nconsole.log(blockLet); // Error: blockLet is not defined\n```\n\n**5. Lexical Scope:**\nLexical scope means that functions are executed using the variable scope that was in effect when they were defined, not the scope they are executed in.\n\n```javascript\nconst outer = () => {\n    const localVar = \"I'm from outer.\";\n    \n    const inner = () => {\n        console.log(localVar); // Output: I'm from outer.\n    };\n    \n    return inner;\n};\n\nconst innerFunction = outer();\ninnerFunction();\n```\n\nThese are the key concepts related to function scope and hoisting in JavaScript. Properly understanding and managing scope and hoisting is crucial for writing code that behaves predictably and avoids bugs.","slug":"Scope","title":"Function Scope and Hoisting in JavaScript","section":"Functions","icon":"info-circle","filePath":"/home/runner/work/amanj-course/amanj-course/lessons/06-Functions/02-Scope.md","nextSlug":"/amanj-course/lessons/Functions/Parameters","prevSlug":"/amanj-course/lessons/Functions/Introduction"}},"__N_SSG":true}